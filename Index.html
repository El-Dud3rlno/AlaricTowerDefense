<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>TD — Rifts: Boss-Only Shooters</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#111; }
    canvas { display:block; touch-action:none; }
    #ui {
      position:absolute; top:10px; left:10px; color:#fff;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size:18px; z-index:5;
      background:rgba(0,0,0,0.45); padding:10px; border-radius:8px; border:1px solid #666;
      user-select:none;
    }
    #ui .row { display:flex; gap:8px; align-items:center; margin-top:8px; }
    #ui button {
      font-size:18px; padding:6px 12px; background:#333; color:#fff;
      border:1px solid #888; border-radius:6px; cursor:pointer;
    }
    #ui button[disabled] { opacity:0.5; cursor:not-allowed; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="hud">Loading…</div>
    <div class="row">
      <button id="toggle">Tower: Fast (25)</button>
      <button id="startRound">Start Rift</button>
    </div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const toggleBtn = document.getElementById('toggle');
    const startBtn = document.getElementById('startRound');

    let width = window.innerWidth, height = window.innerHeight;
    canvas.width = width; canvas.height = height;
    window.addEventListener('resize', () => {
      width = window.innerWidth; height = window.innerHeight;
      canvas.width = width; canvas.height = height;
      makePath();
    });

    const TOWER_INFO = {
      fast:      { cost:25,  dmg:6,  rof:14,  color:'blue',      baseHP:70,  special:null },
      heavy:     { cost:50,  dmg:32, rof:48,  color:'red',       baseHP:120, special:'splash' },
      dual:      { cost:100, dmg:10, rof:26,  color:'purple',    baseHP:105, special:'dual'  },
      fire:      { cost:40,  dmg:8,  rof:22,  color:'#ff6b3a',   baseHP:90,  special:'burn' },
      ice:       { cost:35,  dmg:6,  rof:20,  color:'#69d2ff',   baseHP:85,  special:'slow' },
      lightning: { cost:45,  dmg:12, rof:24,  color:'#f6e05e',   baseHP:95,  special:'chain' },
      poison:    { cost:40,  dmg:7,  rof:22,  color:'#32cd32',   baseHP:90,  special:'poison' }
    };
    const ORDER = ['fast','heavy','dual','fire','ice','lightning','poison'];
    function statsFor(type){ return TOWER_INFO[type]; }
    function towerLabel(type){ return 'Tower: ' + type.charAt(0).toUpperCase()+type.slice(1) + ' ('+statsFor(type).cost+')'; }

    let towerType = 'fast';
    toggleBtn.onclick = () => {
      const i = ORDER.indexOf(towerType);
      towerType = ORDER[(i+1)%ORDER.length];
      toggleBtn.textContent = towerLabel(towerType);
    };

    const towers = [], enemies = [], tBullets = [], eBullets = [], lootDrops = [];
    let points = 150, baseHealth = 150, round = 0;
    let spawning = false;

    let paths = [];
    function makePath(){
      // Create 4 distinct paths with varying crossings
      paths = [
        // Path 1: Top route with crossings
        [
          {x: 10,            y: height*0.25},
          {x: width*0.20,    y: height*0.25},
          {x: width*0.35,    y: height*0.50},  // crossing point
          {x: width*0.50,    y: height*0.25},
          {x: width*0.70,    y: height*0.25},
          {x: width*0.85,    y: height*0.50},  // crossing point
          {x: width-10,      y: height*0.50}
        ],
        // Path 2: Bottom route
        [
          {x: 10,            y: height*0.75},
          {x: width*0.25,    y: height*0.75},
          {x: width*0.35,    y: height*0.50},  // crossing point
          {x: width*0.50,    y: height*0.75},
          {x: width*0.75,    y: height*0.75},
          {x: width*0.85,    y: height*0.50},  // crossing point
          {x: width-10,      y: height*0.50}
        ],
        // Path 3: Middle serpentine
        [
          {x: 10,            y: height*0.50},
          {x: width*0.20,    y: height*0.50},
          {x: width*0.35,    y: height*0.35},
          {x: width*0.50,    y: height*0.50},
          {x: width*0.65,    y: height*0.65},
          {x: width*0.85,    y: height*0.50},
          {x: width-10,      y: height*0.50}
        ],
        // Path 4: Zigzag route
        [
          {x: 10,            y: height*0.40},
          {x: width*0.20,    y: height*0.60},
          {x: width*0.35,    y: height*0.40},
          {x: width*0.50,    y: height*0.60},
          {x: width*0.65,    y: height*0.40},
          {x: width*0.80,    y: height*0.60},
          {x: width-10,      y: height*0.50}
        ]
      ];
    }
    makePath();

    // Rift scaling
    function hpMultForRound(r){ return Math.pow(1.12, r); }
    function spdMultForRound(r){ return Math.min(1 + 0.015*r, 1.6); }
    function dmgMultForRound(r){ return 1 + 0.08*r; }
    function countForRound(r){ return 6 + Math.floor(r*1.6); }
    function spawnGapForRound(r){ return Math.max(250, 700 * Math.pow(0.96, r)); }

    // Elites
    const AFFIXES = ['fast','armored','regen','shielded'];
    function rollAffix(){
      if (Math.random() < Math.min(0.10 + round*0.01, 0.35)) {
        return AFFIXES[Math.floor(Math.random()*AFFIXES.length)];
      }
      return null;
    }

    // Tower Affixes (Diablo-style loot system)
    const TOWER_AFFIXES = [
      { name: 'Powerful', stat: 'dmg', mult: 1.25, color: '#ff6b6b' },
      { name: 'Swift', stat: 'rof', mult: 0.80, color: '#4ecdc4' }, // Lower rof = faster attacks
      { name: 'Precise', stat: 'range', mult: 1.30, color: '#ffe66d' },
      { name: 'Resilient', stat: 'hp', mult: 1.40, color: '#95e1d3' },
      { name: 'Deadly', stat: 'dmg', mult: 1.50, color: '#f38181' },
      { name: 'Rapid', stat: 'rof', mult: 0.65, color: '#48dbfb' }, // Lower rof = faster attacks
      { name: 'Fortified', stat: 'hp', mult: 1.70, color: '#a8e6cf' },
      { name: 'Sharpshooter', stat: 'range', mult: 1.50, color: '#ffd93d' }
    ];

    function rollTowerAffixes(isBoss = false) {
      const affixCount = isBoss ? Math.floor(Math.random() * 2) + 2 : Math.random() < 0.4 ? 1 : 0; // bosses: 2-3 affixes, regular: 0-1 affixes
      if (affixCount === 0) return [];
      
      const rolled = [];
      const available = [...TOWER_AFFIXES];
      for (let i = 0; i < affixCount && available.length > 0; i++) {
        const idx = Math.floor(Math.random() * available.length);
        rolled.push(available[idx]);
        available.splice(idx, 1);
      }
      return rolled;
    }

    class TowerLoot {
      constructor(x, y, type, affixes = []) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.affixes = affixes;
        this.r = 12;
        this.pulseTime = 0;
      }
      
      update() {
        this.pulseTime += 0.05;
      }
      
      draw() {
        const pulse = Math.sin(this.pulseTime) * 0.3 + 1;
        const s = statsFor(this.type);
        
        // Draw glow
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = s.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r * pulse * 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        
        // Draw loot icon (larger)
        ctx.fillStyle = s.color;
        ctx.fillRect(this.x - 10, this.y - 10, 20, 20);
        
        // Draw border based on rarity (affix count)
        const borderColor = this.affixes.length >= 2 ? '#ffd700' : this.affixes.length === 1 ? '#4ecdc4' : '#999';
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 3;
        ctx.strokeRect(this.x - 10, this.y - 10, 20, 20);
        
        // Draw "?" text on loot
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('?', this.x, this.y);
      }
      
      isNear(px, py, radius = 50) {
        return Math.hypot(this.x - px, this.y - py) < radius;
      }
    }

    class Tower {
      constructor(x, y, type='fast', affixes=[]){
        this.x=x; this.y=y; this.type=type; this.affixes=affixes; this.cool=0; this.range=125;
        const s = statsFor(type);
        this.maxHP = s.baseHP; this.hp = this.maxHP;
        
        // Apply affixes
        for (const affix of affixes) {
          if (affix.stat === 'hp') {
            this.maxHP = Math.floor(this.maxHP * affix.mult);
            this.hp = this.maxHP;
          } else if (affix.stat === 'range') {
            this.range = Math.floor(this.range * affix.mult);
          }
        }
      }
      
      getModifiedStat(baseStat, statName) {
        let value = baseStat;
        for (const affix of this.affixes) {
          if (affix.stat === statName) {
            value *= affix.mult;
          }
        }
        return value;
      }
      
      update(){
        if (this.cool>0) this.cool--;
        let target=null, nd=1e9;
        for (const e of enemies){
          const d = Math.hypot(e.x-this.x, e.y-this.y);
          if (d<this.range && d<nd){ target=e; nd=d; }
        }
        if (!target || this.cool>0) return;
        const s = statsFor(this.type);
        const dmg = this.getModifiedStat(s.dmg, 'dmg');
        const rof = this.getModifiedStat(s.rof, 'rof');
        
        if (s.special==='dual'){
          tBullets.push(new TBullet(this.x,this.y,target,dmg, this.type));
          tBullets.push(new TBullet(this.x,this.y,target,dmg*2, this.type));
        } else if (s.special==='splash'){
          tBullets.push(new TBullet(this.x,this.y,target,dmg, this.type, {splash:true, radius:40, splashPct:0.5}));
        } else if (s.special==='chain'){
          tBullets.push(new TBullet(this.x,this.y,target,dmg, this.type, {chain:true, range:110, chainPct:0.6}));
        } else {
          tBullets.push(new TBullet(this.x,this.y,target,dmg, this.type));
        }
        this.cool = rof;
      }
      draw(){
        const s = statsFor(this.type);
        ctx.fillStyle = s.color;
        ctx.fillRect(this.x-10, this.y-10, 20, 20);
        
        // Draw affix border
        if (this.affixes.length > 0) {
          const borderColor = this.affixes.length >= 2 ? '#ffd700' : '#4ecdc4';
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = 2;
          ctx.strokeRect(this.x-10, this.y-10, 20, 20);
        }
        
        ctx.fillStyle='#000'; ctx.fillRect(this.x-12, this.y+12, 24, 4);
        ctx.fillStyle='#4caf50'; ctx.fillRect(this.x-12, this.y+12, 24*(this.hp/this.maxHP), 4);
      }
    }

    class Enemy {
      constructor(isBoss=false, scale=1, affix=null, pathIndex=null){
        this.isBoss=isBoss; this.i=0; this.affix=affix;
        this.pathIndex = pathIndex !== null ? pathIndex : Math.floor(Math.random() * paths.length);
        this.path = paths[this.pathIndex];
        this.x=this.path[0].x; this.y=this.path[0].y;

        const baseHP = isBoss ? 1200 : 160;
        const baseSPD = isBoss ? 0.85 : 0.9;

        const hp = baseHP * hpMultForRound(round) * scale * (isBoss ? 6.5 : 1);
        const sp = baseSPD * spdMultForRound(round) * (affix==='fast' ? 1.25 : 1);

        this.hp = Math.floor(hp);
        this.max = this.hp;
        this.speed = sp;
        this.r = isBoss?24:10;

        // status effects
        this.burnTicks=0; this.burnDmg=0;
        this.slowTimer=0;
        this.poisonTicks=0; this.poisonDmg=0;

        // defensive affixes
        this.armor = (affix==='armored') ? 0.35 : 0;
        this.regen = (affix==='regen') ? (1 + 0.15*round) : 0;
        this.shield = (affix==='shielded') ? Math.min(40 + 6*round, 250) : 0;

        // shooting: BOSSES ONLY
        this.cool = this.isBoss ? 60 : Infinity;
      }
      applyDOTs(){
        if (this.burnTicks>0){ this.hp -= this.burnDmg; this.burnTicks--; }
        if (this.poisonTicks>0){ this.hp -= this.poisonDmg; this.poisonTicks--; }
      }
      tickRegen(){
        if (this.regen>0 && this.hp>0 && this.hp<this.max){ this.hp = Math.min(this.max, this.hp + this.regen); }
      }
      shootAtNearestTower(){
        if (towers.length===0) return;
        let t=null, nd=1e9;
        for (const tw of towers){
          const dd = Math.hypot(tw.x - this.x, tw.y - this.y);
          if (dd < nd){ t = tw; nd = dd; }
        }
        if (!t) return;
        const dmg = Math.ceil(24 * dmgMultForRound(round)); // boss damage scales
        eBullets.push(new EBullet(this.x, this.y, t, dmg));
      }
      update(){
        if (this.slowTimer>0) this.slowTimer--;
        this.applyDOTs();
        this.tickRegen();

        const nxt = this.path[this.i+1];
        if (!nxt){
          baseHealth -= this.isBoss?Math.ceil(18 * dmgMultForRound(round)):10;
          const idx=enemies.indexOf(this); if (idx>=0) enemies.splice(idx,1);
          return;
        }
        const effSPD = this.speed * (this.slowTimer>0 ? 0.55 : 1.0);
        const dx=nxt.x-this.x, dy=nxt.y-this.y, d=Math.hypot(dx,dy);
        if (d<effSPD) this.i++; else { this.x+=dx/d*effSPD; this.y+=dy/d*effSPD; }

        // bosses shoot on cooldown
        if (this.isBoss){
          this.cool--;
          if (this.cool<=0){
            this.shootAtNearestTower();
            this.cool = 60;
          }
        }
      }
      draw(){
        let c = this.isBoss ? '#3b146b' : 'green';
        if (!this.isBoss && this.affix){
          c = (this.affix==='fast')?'#7ed957':(this.affix==='armored')?'#9aa0a6':(this.affix==='regen')?'#6ee7b7':'#60a5fa';
        }
        ctx.fillStyle = c;
        ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill();

        const barW = 32, barH=5;
        const px = this.x - barW/2, py = this.y - this.r - 10;
        ctx.fillStyle='#000'; ctx.fillRect(px, py, barW, barH);
        ctx.fillStyle='#e74c3c'; ctx.fillRect(px, py, barW*(this.hp/this.max), barH);
        if (this.shield>0){
          const shieldRatio = Math.min(1, this.shield / (this.max*0.5));
          ctx.fillStyle='rgba(135,206,235,0.8)'; ctx.fillRect(px, py, barW*shieldRatio, barH);
        }
      }
      takeDamage(amount){
        if (this.shield>0){
          const used = Math.min(this.shield, amount);
          this.shield -= used; amount -= used;
        }
        if (amount<=0) return;
        amount *= (1 - this.armor);
        this.hp -= amount;
      }
    }

    class TBullet {
      constructor(x,y,target,damage, towerType, opts={}){
        this.x=x; this.y=y; this.t=target; this.dmg=damage; this.towerType=towerType; this.opts=opts;
        this.speed = 6.2;
      }
      update(){
        if (!enemies.includes(this.t) || this.t.hp<=0) return this.kill();
        const dx=this.t.x-this.x, dy=this.t.y-this.y, d=Math.hypot(dx,dy);
        if (d<this.speed){
          // Elemental synergies
          let finalDmg = this.dmg;
          if (this.towerType==='poison' && this.t.isBoss) finalDmg *= 1.5; // poison bonus vs bosses
          if (this.towerType==='ice'){ this.t.slowTimer = Math.max(this.t.slowTimer, 60); } // slow applied
          if (this.towerType==='lightning' && this.t.slowTimer>0) finalDmg *= 1.5; // lightning bonus on slowed

          this.t.takeDamage(finalDmg);

          // DoTs and specials
          if (this.towerType==='fire'){ this.t.burnTicks = Math.max(this.t.burnTicks, 30); this.t.burnDmg = 1.5; }
          if (this.towerType==='poison'){ this.t.poisonTicks = Math.max(this.t.poisonTicks, 90); this.t.poisonDmg = 0.8; }
          if (this.opts.splash){
            for (const e of enemies){
              if (e===this.t) continue;
              if (Math.hypot(e.x-this.t.x, e.y-this.t.y) <= this.opts.radius) e.takeDamage(finalDmg*this.opts.splashPct);
            }
          }
          if (this.opts.chain){
            let sec=null, nd=Infinity;
            for (const e of enemies){
              if (e===this.t) continue;
              const dd = Math.hypot(e.x-this.t.x, e.y-this.t.y);
              if (dd < this.opts.range && dd < nd){ sec=e; nd=dd; }
            }
            if (sec){ tBullets.push(new TBullet(this.t.x, this.t.y, sec, finalDmg*this.opts.chainPct, this.towerType)); }
          }
          return this.kill();
        }
        this.x+=dx/d*this.speed; this.y+=dy/d*this.speed;
      }
      draw(){
        const c = (this.towerType==='fire') ? '#ff9b58'
                : (this.towerType==='ice') ? '#b3ecff'
                : (this.towerType==='lightning') ? '#ffe66d'
                : (this.towerType==='poison') ? '#90ee90'
                : (this.towerType==='heavy') ? '#ffdddd'
                : (this.towerType==='dual') ? '#e1c4ff'
                : 'yellow';
        ctx.fillStyle = c; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
      }
      kill(){ const i=tBullets.indexOf(this); if (i>=0) tBullets.splice(i,1); }
    }

    class EBullet {
      constructor(x,y,target,damage){ this.x=x; this.y=y; this.t=target; this.dmg=damage; this.speed=5.5; }
      update(){
        if (!towers.includes(this.t)) return this.kill();
        const dx=this.t.x-this.x, dy=this.t.y-this.y, d=Math.hypot(dx,dy);
        if (d<this.speed){
          this.t.hp -= this.dmg;
          if (this.t.hp <= 0){
            const i=towers.indexOf(this.t); if (i>=0) towers.splice(i,1);
          }
          return this.kill();
        }
        this.x+=dx/d*this.speed; this.y+=dy/d*this.speed;
      }
      draw(){ ctx.fillStyle='#b084f5'; ctx.beginPath(); ctx.arc(this.x,this.y,3.5,0,Math.PI*2); ctx.fill(); }
      kill(){ const i=eBullets.indexOf(this); if (i>=0) eBullets.splice(i,1); }
    }

    function canStartRound(){ return !spawning && enemies.length===0 && baseHealth>0; }
    function updateStartButton(){ startBtn.disabled = !canStartRound(); }
    startBtn.onclick = () => { if (canStartRound()) startRound(); };

    function startRound(){
      spawning = true; round++;
      for (const t of towers){ t.maxHP += 6; t.hp = Math.min(t.maxHP, t.hp + 6); }

      const count = countForRound(round);
      const gap = spawnGapForRound(round);

      for (let i=0;i<count;i++){
        setTimeout(()=>{
          const isBoss = (round%5===0) && (i===0);
          const waveScale = 1 + (i/count)*0.35;
          const affix = isBoss ? null : rollAffix();
          enemies.push(new Enemy(isBoss, waveScale, affix));
        }, i*gap);
      }
      setTimeout(()=> { spawning=false; updateStartButton(); }, count*gap + 400);
      updateStartButton();
    }

    let lastPlaceAt = 0;
    let pickedUpLoot = null;
    
    function placeAt(x,y){
      // Check if clicking near loot
      for (let i = lootDrops.length - 1; i >= 0; i--) {
        const loot = lootDrops[i];
        if (loot.isNear(x, y)) {
          pickedUpLoot = loot;
          lootDrops.splice(i, 1);
          toggleBtn.textContent = towerLabel(loot.type) + (loot.affixes.length > 0 ? ' +' + loot.affixes.length : '');
          return;
        }
      }
      
      // Place tower (from loot or regular)
      if (pickedUpLoot) {
        const t = new Tower(x, y, pickedUpLoot.type, pickedUpLoot.affixes);
        towers.push(t);
        pickedUpLoot = null;
        toggleBtn.textContent = towerLabel(towerType);
        return;
      }
      
      // Regular tower placement
      const s = statsFor(towerType);
      if (points<s.cost) return;
      const t = new Tower(x,y,towerType);
      towers.push(t);
      points -= s.cost;
    }
    canvas.addEventListener('pointerdown', (e) => {
      if (!e.isPrimary) return;
      e.preventDefault();
      const now = performance.now();
      if (now - lastPlaceAt < 250) return;
      lastPlaceAt = now;
      const rect = canvas.getBoundingClientRect();
      placeAt(e.clientX - rect.left, e.clientY - rect.top);
    }, {passive:false});

    function drawPath(){
      ctx.strokeStyle='rgba(255,255,255,0.22)'; ctx.lineWidth=18; ctx.lineCap='round';
      for (const path of paths) {
        ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y);
        for (let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
        ctx.stroke();
      }
    }

    function loop(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawPath();

      for (const e of [...enemies]) e.update();
      for (let i=enemies.length-1;i>=0;i--){
        if (enemies[i].hp<=0){
          const e = enemies[i];
          points += e.isBoss ? 60 : 15;
          
          // Drop loot chance
          const dropChance = e.isBoss ? 0.8 : 0.25;
          if (Math.random() < dropChance) {
            const lootType = ORDER[Math.floor(Math.random() * ORDER.length)];
            const lootAffixes = rollTowerAffixes(e.isBoss);
            lootDrops.push(new TowerLoot(e.x, e.y, lootType, lootAffixes));
          }
          
          enemies.splice(i,1);
        }
      }
      for (const t of towers) t.update();
      for (const b of [...tBullets]) b.update();
      for (const b of [...eBullets]) b.update();
      for (const l of lootDrops) l.update();

      for (const t of towers) t.draw();
      for (const l of lootDrops) l.draw();
      for (const b of tBullets) b.draw();
      for (const b of eBullets) b.draw();
      for (const e of enemies) e.draw();

      updateStartButton();
      let hudText = `Points: ${points} | Base Health: ${baseHealth} | Rift: ${round} ${spawning?'(spawning…)':(canStartRound()?'(ready)':'')}`;
      if (pickedUpLoot) {
        const lootTypeName = pickedUpLoot.type.charAt(0).toUpperCase() + pickedUpLoot.type.slice(1);
        hudText += ` | LOOT: ${lootTypeName}`;
        if (pickedUpLoot.affixes.length > 0) {
          hudText += ' [' + pickedUpLoot.affixes.map(a => a.name).join(', ') + ']';
        }
        hudText += ' - Click to place';
      } else if (lootDrops.length > 0) {
        hudText += ` | ${lootDrops.length} Loot drop(s) available`;
      }
      hud.textContent = hudText;

      if (baseHealth<=0){
        ctx.fillStyle='red'; ctx.font='40px Arial'; ctx.fillText('Rift Closed — You Died', width/2-190, height/2);
        return;
      }
      requestAnimationFrame(loop);
    }
    toggleBtn.textContent = towerLabel(towerType);
    updateStartButton();
    loop();
  </script>
</body>
</html>
